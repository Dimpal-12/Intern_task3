"""
chatbot.py
A simple NLP chatbot using NLTK + TF-IDF similarity.
Author: Generated by ChatGPT (GPT-5 Thinking mini)
Usage:
    python run_chatbot.py
Requires:
    nltk, scikit-learn (optional but recommended)
If scikit-learn is not available, a simple keyword-overlap fallback is used.
"""
import random
import nltk
from nltk.corpus import stopwords
from nltk.stem import PorterStemmer
from nltk.tokenize import word_tokenize, sent_tokenize

try:
    from sklearn.feature_extraction.text import TfidfVectorizer
    from sklearn.metrics.pairwise import cosine_similarity
    SKLEARN_AVAILABLE = True
except Exception:
    SKLEARN_AVAILABLE = False

# download required NLTK data (first run will fetch)
nltk.download('punkt', quiet=True)
nltk.download('stopwords', quiet=True)

STOPWORDS = set(stopwords.words('english'))
STEMMER = PorterStemmer()

def preprocess(text):
    tokens = word_tokenize(text.lower())
    tokens = [t for t in tokens if t.isalpha() and t not in STOPWORDS]
    stems = [STEMMER.stem(t) for t in tokens]
    return " ".join(stems)

class Chatbot:
    def __init__(self, kb_path):
        self.kb_path = kb_path
        self.load_kb()
        if SKLEARN_AVAILABLE:
            self.vectorizer = TfidfVectorizer()
            self.tfidf_matrix = self.vectorizer.fit_transform(self.kb_processed)
        else:
            # build simple keyword index
            self.kb_keywords = [set(preprocess(s).split()) for s in self.kb_sentences]

    def load_kb(self):
        with open(self.kb_path, 'r', encoding='utf-8') as f:
            text = f.read()
        # split into sentences
        self.kb_sentences = [s.strip() for s in sent_tokenize(text) if s.strip()]
        self.kb_processed = [preprocess(s) for s in self.kb_sentences]

    def respond(self, query, top_k=1):
        if not query.strip():
            return "Please type something so I can help."
        if SKLEARN_AVAILABLE:
            q_proc = preprocess(query)
            q_vec = self.vectorizer.transform([q_proc])
            sims = cosine_similarity(q_vec, self.tfidf_matrix)[0]
            best_idx = int(sims.argmax())
            if sims[best_idx] < 0.1:
                return self.fallback(query)
            return self.kb_sentences[best_idx]
        else:
            q_kw = set(preprocess(query).split())
            scores = []
            for idx, kws in enumerate(self.kb_keywords):
                scores.append((len(kws & q_kw), idx))
            scores.sort(reverse=True)
            if scores and scores[0][0] > 0:
                return self.kb_sentences[scores[0][1]]
            return self.fallback(query)

    def fallback(self, query):
        # Simple fallback using keyword matching to provide multiple possible matches
        keywords = preprocess(query).split()
        matches = []
        for s in self.kb_sentences:
            if any(k in s.lower() for k in keywords[:3]):
                matches.append(s)
        if matches:
            return random.choice(matches)
        return "Sorry, I don't know the answer to that right now. Try asking about internships, tasks, or tools."

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Simple NLP Chatbot")
    parser.add_argument("--kb", default="kb.txt", help="Path to knowledge base (text file)")
    args = parser.parse_args()

    bot = Chatbot(args.kb)
    print("Chatbot ready. Type 'exit' or 'quit' to stop.")
    while True:
        q = input("You: ").strip()
        if q.lower() in ("exit","quit"):
            print("Bot: Goodbye!")
            break
        print("Bot:", bot.respond(q))
